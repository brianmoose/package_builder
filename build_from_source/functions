#!/bin/bash
####
# set common functions
ccache_enable() {
    if [ -n "$NO_CCACHE" ]; then return; fi
    if [ -d /opt/ccache ]; then
        echo -e "Enabling CCACHE..."
        export PATH=/opt/ccache/bin:$PATH
        if [ `uname` == "Darwin" ] && [ "$CC" == "" ]; then
            CC="clang"; CXX="clang++"
        elif [ `uname` == "Linux" ] && [  "$CC" == "" ]; then
            CC="gcc"; CXX="g++"
        fi
        export CC="ccache $CC" CXX="ccache $CXX"
        echo -e "CC=$CC CXX=$CXX"
        echo "which ccache: "`which ccache`
    fi
}

with_lock() {
    lock_count=0
    while [ $lock_count -lt 350 ]; do
        let lock_count=$lock_count+1
        # mkdir is atomic
        mkdir "$1"
        mkdir_code=$?
        if [ "$mkdir_code" != "0" ]; then
            sleep 1
        else
            return
        fi
    done
    echo "Failed to lock $1 within 5 minutes"
    cleanup 1
}

try_command() {
    allowed_count=$1
    command_string="$2"
    try_count=0
    while [ "$try_count" -lt "$allowed_count" ]; do
        let try_count=try_count+1
        eval "$command_string"
        retcode=$?
        if [ "$retcode" != "0" ] && [ "$try_count" == "$allowed_count" ]; then
            echo "Failed $1 times, trying to execute: $command_string"
            cleanup 1
        elif [ "$retcode" != "0" ]; then
            sleep 30
        else
            return
        fi
    done
}

pause() {
    if [ "$DEBUG" = true ]; then
        read -p "Press Enter to continue.."
    fi
}

md5sum_check() {
    REMOTE_MD5FILE="$1.md5"
    LOCAL_MD5FILE="$1.local_md5"
    MD5_DIFF="false"

    echo "Running md5sum check..."
    # Apple always gotta be different :(
    # Create a temporary md5 file based on local downloaded data file
    if [ `uname` != "Darwin" ]; then
        md5sum "$DOWNLOAD_DIR/$1" | cut -d\  -f 1 > "$DOWNLOAD_DIR/$LOCAL_MD5FILE"
    else
        md5 "$DOWNLOAD_DIR/$1" | cut -d\  -f 4 > "$DOWNLOAD_DIR/$LOCAL_MD5FILE"
    fi

    # Perform the diff and set a diff flag if found
    diff "$DOWNLOAD_DIR/$REMOTE_MD5FILE" "$DOWNLOAD_DIR/$LOCAL_MD5FILE"
    diff_code=$?
    rm -f "$DOWNLOAD_DIR/$LOCAL_MD5FILE"
    if [ "$diff_code" != "0" ]; then
        echo "Downloaded file: $1 is different than file on remote server..."
        MD5_DIFF="true"
    else
        echo "Files are similar..."
    fi
}

download() {
    if [ "$DOWNLOAD" = "false" ]; then return; fi
    for url in ${DOWNLOAD[*]}; do
        echo "Attempting to download file: $url"
        BASENAME=`basename $url`

        # Wait for lock
        with_lock "$DOWNLOAD_LOCKS/$BASENAME.lock"

        # If file is not present, download it and the corresponding md5
        if ! [ -f "$DOWNLOAD_DIR/$BASENAME" ]; then
            try_command 5 "curl -o $DOWNLOAD_DIR/$BASENAME $url"
            try_command 5 "curl -o $DOWNLOAD_DIR/$BASENAME.md5 $url.md5"
            if [ `file "$DOWNLOAD_DIR/$BASENAME" | grep -c "gzip\|archive\|compressed\|data\|executable"` -le 0 ] || [ `file "$DOWNLOAD_DIR/$BASENAME.md5" | grep -c "ASCII text"` -le 0 ]; then
                echo -e "Downloaded file was not an archive: \n"
                file "$DOWNLOAD_DIR/$BASENAME"
                rm -f "$DOWNLOAD_DIR/$BASENAME" "$DOWNLOAD_DIR/$BASENAME.md5"
                cleanup 1
            fi
            md5sum_check "$BASENAME"
            if [ "$MD5_DIFF" = "true" ]; then
                rm -f "$DOWNLOAD_DIR/$BASENAME" "$DOWNLOAD_DIR/$BASENAME.md5"
                cleanup 1
            fi
        else
            echo "File previously downloaded is the latest available, moving on..."
        fi

        # Remove the lock
        rm -rf "$DOWNLOAD_LOCKS/$BASENAME.lock"
    done
}

extract() {
    if [ "$EXTRACT" = "false" ]; then return; fi
    for DFILE in ${EXTRACT[*]}; do
        echo "Extracting $DOWNLOAD_DIR/$DFILE..."
        if [ `file $DOWNLOAD_DIR/$DFILE | grep -c "gzip\|archive\|compressed"` -ge 1 ]; then
            tar -xf "$DOWNLOAD_DIR/$DFILE" -C .
            if [ $? -ne 0 ]; then
                echo "Failed to extract $DFILE"
                cleanup 1
            fi
        else
            echo "File appears not to be an archive: $DFILE"
            cleanup 1
        fi
    done
    # Lets hope the tarballs were created correctly
    cd $(tar -tf $DOWNLOAD_DIR/${EXTRACT[0]} | sed -e 's@/.*@@' | uniq)
    if [ $? -ne 0 ]; then
        echo -e "Failed to determine which directory to `cd` into"
        cleanup 1
    else
        echo -e "Entered build directory: `pwd`"
    fi
}

configure() {
    if [ "$CONFIGURE" = "false" ]; then return; fi
    echo -e "Configure $PACKAGE with the following options: $CONFIGURE"
    pause
    eval "$CONFIGURE"
    if [ $? -ne 0 ]; then echo "Failed to configure using following options: $CONFIGURE"; cleanup 1; fi
    pause
}

build() {
    if [ "$BUILD" = "false" ]; then return; fi
    echo -e "Building $PACKAGE with JOB count: $MOOSE_JOBS"
    pause
    # If $MAX is set, use all available CPUs for this one job
    if [ ! -z "$MAX" ]; then
        if [ `uname -s` == "Darwin" ]; then
            MOOSE_JOBS=`/usr/sbin/sysctl -n hw.ncpu`
        else
            MOOSE_JOBS=`cat /proc/cpuinfo | grep processor | wc -l`
        fi
    fi
    ccache_enable
    make -j $MOOSE_JOBS -l $MOOSE_JOBS
    if [ $? -ne 0 ]; then echo "Failed to make $1"; cleanup 1; fi
    pause
}

make_install() {
    if [ "$INSTALL" = "false" ]; then return; fi
    echo -e "Installing $PACKAGE..."
    pause
    make install
    if [ $? -ne 0 ]; then echo "Failed to install $1"; cleanup 1; fi
}
clean_attempt() {
    # Clean a possible failed previous build directory
    if [ -d "$src_temp" ]; then
        rm -rf "$src_temp"
    fi
    mkdir -p "$src_temp"
    cd "$src_temp"
}

cleanup() {
    if [ $1 == 0 ]; then
        echo "Deleting temporary build location: $src_temp"
        rm -rf "$src_temp"
    elif [ -z "$KEEP_FAILED" ]; then
        echo "Error while working on: $PACKAGE"
        rm -rf "$src_temp"
    else
        echo "Error while working on: $PACKAGE located at: $src_temp"
    fi
    exit $1
}

umask 022
ME=`basename "$0"`
PROGRESS="$RELATIVE_DIR/progress"
export src_temp="$TEMP_PREFIX/$PACKAGE"

CONTINUE="false"
for OPERATING_SYSTEM in ${ARCH[*]}; do
    if [ "$OPERATING_SYSTEM" == `uname` ]; then CONTINUE="true"; fi
done

if [ "$DOWNLOAD_ONLY" == "True" ] && [ "$CONTINUE" == "true" ]; then
    download
    exit 0
elif [ "$CONTINUE" == "true" ]; then
    touch $PROGRESS
    if [ `grep -c $ME $PROGRESS` -eq 0 ]; then
        error=""
        for dependency in ${DEP[*]}; do
            if [ `grep -ci ^$dependency $PROGRESS` -eq 0 ]; then
                error+=$dependency' '
            fi
        done
        if ! [ -z "$error" ]; then
            echo -e "\nDependencies not met: $error"
            exit 0
        fi
        clean_attempt
        download
        extract
        pre_run "$src_temp"
        configure
        build
        make_install
        post_run "$src_temp"
        echo $ME >> $PROGRESS
        cleanup 0
    else
        echo -e "$ME previously built"
    fi
fi
